---
title: 特别好用的二分查找法模板
layout: post
categories: 数据结构与算法
tags: 二分法

---

* TOC
{:toc}


[LeetCode 第 35 题：搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

## 一、传统二分查找法模板

刚接触二分查找法的时候，我们可能会像下面这样写代码，我把这种写法容易出错的地方写在了注释里：

Java 代码：

```
public class Solution {

    public int searchInsert(int[] nums, int target) {
        int len = nums.length;
        if (nums[len - 1] < target) {
            return len;
        }

        int l = 0;
        int r = len - 1;

        while (l <= r) {
            int mid = (l + r) / 2;
            // 等于的情况最简单，我们放在第 1 个分支进行判断
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                // 题目要我们返回大于或者等于目标值的第 1 个数的索引
                // 此时 mid 一定不是所求的左边界，
                // 此时左边界更新为 mid + 1
                l = mid + 1;
            } else {
                // 既然不会等于，此时 nums[mid] > target
                // mid 也一定不是所求的右边界
                // 此时右边界更新为 mid - 1
                r = mid - 1;
            }
        }
        // 注意：一定得返回左边界 l，
        // 如果返回右边界 r 提交代码不会通过
        // 下面我尝试说明一下理由，如果你不太理解下面我说的，那是我的表达问题
        // 【注意】建议你不要纠结这个问题，因为我马上介绍的二分法模板，可以避免对返回 l 和 r 的思考

        // 理由是对于 [1,3,5,6]，target = 2，返回大于等于 target 的第 1 个数的索引，此时应该返回 1
        // 在上面的 while (l <= r) 退出循环以后，r < l，r = 0 ，l = 1
        // 根据题意应该返回 l，
        // 如果题目要求你返回小于等于 target 的所有数里最大的那个索引值，应该返回 r

        return l;
    }
}        
```

> 传统二分查找法的问题在于，当退出 while 循环的时候，应该返回左边界还是右边界比较容易出错。

那么是不是可以回避这个问题呢？答案是肯定的，并且只要你掌握了下面我介绍的“神奇的”二分查找法模板，你会屡试不爽的。
<!-- more -->

## 二、“神奇的”二分查找法模板

在一些资料中，你可能看过别人写二分查找法，把循环可以进行的条件写成 `while (l < r)` ，当时你是不是跟我一样有疑问，咦？当左右边界一样的时候，那个数岂不是会被漏掉。但是我要告诉你，这样写是最好的，这是最好二分查找法“模板”的一部分。

>理由很简单，写 `while (l < r)` 的时候，退出循环时，左边界等于右边界，因此你不必纠结要返回 `l` 还是 `r` ，此时返回 `l` 或者 `r` 都是可以的。

二分查找法之所以高效，是因为它利用了数组有序的特点，在每一次的搜索过程中，都可以排除将近一半的数，使得搜索区间越来越小，直到区间成为一个数。不过这里有个细节要注意：

>1、如果你确定你要找的数一定在左边界和右边界所表示的区间里出现，那么可以放心地返回 l 或者 r；

>2、如果你不确定你要找的数一定在左边界和右边界所表示的区间里出现，那么也没有关系，只要在退出循环以后，再针对 nums[l] 或者 nums[r] （此时 nums[l] == nums[r]）单独作一次判断，看它是不是你要找的数即可。

写 `while (l < r)` 可以避免你对返回左边界还是右边界的讨论。下面给出这道问题，使用 `while (l < r)` 模板写法的参考代码。

Java 代码：

```
public class Solution {

    public int searchInsert(int[] nums, int target) {
        int len = nums.length;
        if (len == 0) {
            return 0;
        }
        if (target > nums[len - 1]) {
            return len;
        }
        int left = 0;
        int right = len - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return right;
    }
}
```

不过写出这段代码还是有一定“技巧”的。

## 三、技巧、调试方法和注意事项

**1、首先，得弄清楚取中点的方式。**

（1）当 `l` 和 `r` 是很大的整数的时候，你写 `int mid = (l + r) / 2`; 这里 `l + r` 就有可能超过 `int` 类型能表示的最大值，因此使用 `mid = l + (r - l) / 2` 可以避免这种情况。

事实上 `mid = l + (r - l) / 2` 在 `r` 很大，并 `l` 是负数且很小的时候， `r - l` 也有可能超过 `int` 类型能表示的最大值，只不过一般情况下 `l` 和 `r` 表示的是数组索引值，`l` 是非负数，因此 `r - l` 溢出的可能性很小。

（2）另外还要注意，当数组的元素个数是偶数的时候，中位数有**左中位数**和**右中位数**之分：

使用 `mid = l + (r - l) / 2` 得到左中位数的索引；

使用 `mid = l + (r - l + 1) / 2` 得到右中位数的索引。

当数组的元素个数是奇数的时候，二者都能选到最中间的那个中位数。

我们使用一个具体的例子来验证这件事情，当索引 `l = 3`，索引 `r = 4` 的时候，左中位数是索引 `l`，右中位数是索引 `r`，这是因为：

`mid = l + (r - l) / 2 = 3 + (4 - 3) / 2 = 3 + 0 = 3`，

`mid = l + (r - l + 1) / 2 = 3 + (4 - 3 + 1) / 2 = 3 + 1 = 4`。

>记忆方法：`(r - l)` **不加 1 选左中位数，加 1 选右中位数。**

那么，什么时候使用左中位数，什么时候使用右中位数呢？这就要看分支的逻辑了。

**2、编写分支的逻辑循序先写“排除逻辑”所在的分支。**

**这里介绍很重要的一个技巧：**先考虑能把“中位数”排除在外的逻辑，而不能排除“中位数”的逻辑放在 else 分支里，这样做的理由有 2 点：

>（1）可以排除“中位数”的逻辑，通常比较好想，但并不绝对，这一点视情况而定；

>（2）分支条数变成 2 条，比原来 3 个分支要考虑的情况少，即**不用单独考虑中位数是否满足题意**，因为退出循环的时候，左右区间**压缩成一个数（索引）**的时候，这个索引表示的数要么满足题意，要么不满足题意，而不必在二分逻辑中单独做判断（这一点很重要，希望读者结合具体例子仔细体会）。

以本题为例，最开始我们就分析了要求我们找到“大于或者等于目标值的第 1 个数的**索引**”。所以对于这道题而言：

（1）如果中位数小于目标值，就应该被排除，左边界 `l` 就至少是 `mid + 1`；

（2）如果中位数大于等于目标值，还不能够肯定它就是我们要找的数，因为要找的是等于目标值的第 1 个数的**索引，中位数以及中位数的左边都有可能是符合题意的数**，因此右边界就不能把 `mid` 排除，因此右边界 `r` 至多是 `mid`，此时右边界不向左边收缩。

**3、根据分支编写的情况，选择使用左中位数还是右中位数**

先写分支，根据分支的逻辑选中位数，选左中位数还是右中位数，这要做的理由是为了防止出现死循环。

>死循环就容易发生在区间元素只有 **2** 个时候，此时中位数的选择尤为关键。

为了避免出现死循环，我们需要确保：

>1、如果分支的逻辑，在选择左边界的时候，不能排除中位数，那么中位数就选“右中位数”，只有这样区间才会收缩，否则进入死循环；

>2、同理，如果分支的逻辑，在选择右边界的时候，不能排除中位数，那么中位数就选“左中位数”，只有这样区间才会收缩，否则进入死循环。

## 四、使用总结

总结一下，我爱用这个模板的原因、技巧、优点和注意事项：

1、原因：无脑地写 `while l < r` ，这样你就不用判断，在退出循环的时候你应该返回 `l` 还是 `r`；

2、技巧：先写分支逻辑，并且先写排除中位数的逻辑分支（因为容易想到），再根据分支的情况选择使用左中位数还是右中位数；

3、优点：分支条数只有 2 条，代码执行效率更高，不用单独判断中位数是否符合题目要求，写分支的逻辑的目的是尽量排除更多的候选元素，而判断中位数是否符合题目要求我们放在最后进行，这就是第 5 点；

4、注意事项 1 ：左中位数还是右中位数选择的标准根据分支的逻辑而来，标准是每一次循环都应该让区间收缩，在区间只剩下 2 个元素的时候，为了避免死循环发生，选择正确的中位数类型。如果你实在很晕，不防就使用有 2 个元素的测试用例，就能明白其中的原因，另外在代码出现死循环的时候，建议你可以将左边界、右边界、你选择的中位数的值，还有分支逻辑都打印输出一下，出现死循环的原因就一目了然了；

5、注意事项 2：如果能确定要找的数就在候选区间里，那么退出循环的时候，区间最后收缩成为 1 个数后，直接把这个数返回即可；如果你要找的数有可能不在候选区间里，区间最后收缩成为 1 个数后，还要单独判断一下这个数是否符合题意；

最后给出模板:

```
public int binary_search(int[] nums, int target) {
    //当分支逻辑不能排除右边界的时候选择左中位数
    //如果选择右中位数，当区间只剩下 2 个元素的时候，
    //一旦进入 r = mid 这个分支，右边界不会收缩，代码进入死循环
    int l = 0;
    int r = nums.length - 1;
    while (l < r) {
        //也可以写成int mid = (low + high) >>> 1而且可有效避免整型溢出 （仅适用于结果保证不是负数的情况）
        int mid = l + (r - l) / 2;
        if (nums[mid] < target) {
        //先写可以排除中位数的逻辑
            l = mid + 1;
        } else {
        //右边界不能排除
            r = mid;
        }
    }
    //退出循环的时候，视情况，是否需要单独判断 l（或者 r）这个索引表示的元素是否符合题意
    return right;
}
```

>说明：写的时候，一般是先默认将中位数写成左中位数，再根据分支的情况，看看是否有必要调整成右中位数，即是不是要在 `(r - l)` 这个括号里面加 1 。
