---
title: 阿里8.21场笔试记录
layout: post
categories: 数据结构与算法
tags: 贪心
---
* TOC
{:toc}  

渣渣秋招找工作真的是寸步难行，阿里笔试没做出来，后来研究通了，特此记录一下： 

#### 描述 
一群N人希望用一条船过河，这条船最多只能载两个人。因此，必须安排某种穿梭安排，才能来回划船，以便所有人都能过关。每个人都有不同的划船速度；一对选手的速度取决于速度较慢的人的速度。你的工作是确定一个策略，尽量减少这些人的过河时间。 

<!-- more -->
#### 输入 

输入的第一行包含一个整数T(1<=T<=20)，测试用例数。接下来是T个案例。每个案例的第一行包含N，第二行包含N个整数，给出每个人过河的时间。每个案例前面都有一个空白行。不会有超过1000人，没有人需要超过100秒的跨越。

#### 输出 
对于每个测试用例，打印一行，其中包含所有N个人过河所需的总秒数。 

#### 样本输入 
```
2
4
2 10 12 11
4
2 3 7 8
```

#### 样本输出 
```
34
19
```

#### 问题分析

（以下N人速度分别用abcd…表示，且按速度升序排序） 

1.当n=1时，time则为a 

2.当n=2时，time则为b 

3.当n=3时，time则为a+b+c（a与任意一个人过河，a再回来，再和剩下的人过河） 

4.当n>= 4 时，问题就复杂很多，因为任意两人过河，再在过了河中其中一个再回来有很多情况，我们这里需要进行分析 


观察题目我们可以发现有两种过河策略： 

1、用过河时间最少的那个人每次载一个到对面，然后再回来载剩下的； 

2、用（耗时）最少的和次少的循环载人，先是最少的和次少的一起过河，再是最少的回来，然后让最多的载次多的过河，再用次少的回来载人 


每轮取时间最少的一种策略，即可得到最少过河时间

```
public int minTime(int n, int[] persons) {
        int res = 0;
        // 将数组按照从小到大排序
        Arrays.sort(persons);
        int len = persons.length;
        for (int i = len - 1; i > 2; i -= 2) {
            // 方案一：耗时最少载最多的过河（用时为persons[i]），最少的回来（用时为persons[0]），
            // 再和次多的一起过去（用时为persons[i - 1]），再用最少的回来载人（用时为persons[0]）
            int tmp1 = persons[0] * 2 + persons[i] + persons[i - 1];
            // 方案二：最少的和次少的一起过河（用时为persons[1]），最少的回来（用时为persons[0]），
            // 然后让最多的载次多的过河（用时为persons[i]），再用次少的回来载人（用时为persons[1]）
            int tmp2 = persons[1] * 2 + persons[0] + persons[i];
            if (tmp1 > tmp2) {
                res += tmp1;
            } else {
                res += tmp2;
            }
        }

        if (len == 1) res += persons[0];
        if (len == 2) {
            res += persons[0] + persons[1];
        }
        if (len == 3) {
            res += persons[0] + persons[1] + persons[2];
        }

        return res;
    }
```