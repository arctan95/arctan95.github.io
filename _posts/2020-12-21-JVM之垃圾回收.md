---
title: JVM之垃圾回收
layout: post
categories: JAVA
tags: JVM
---
TOC {:toc}
### 一、垃圾判断的算法

#### 1.引用计数算法

给对象添加一个引用计数器，当有一个方法引用它，计数器加1，当引用失效，计数器减1。任何时刻计数器为0的对象就是不可能再被使用的

缺点：无法解决对象循环引用的问题（两个互相引用的对象的引用计数最少是1）

#### 2.根搜索算法

通过一系列的称为为`GC Roots`的点作为起始进行向下搜索，当一个对象到`GC Roots`没有任何引用链，则证明此对象是不可用的

在`Java`语言中，`GC Roots`包括

- 1.在**VM栈**（栈中的本地变量）中的引用

- 2.**方法区**中的静态引用

  方法区主要回收两部分内容：**废弃常量**与**无用类**

  - 类回收需要满足三个条件
    - 该类的所有实例都已经被GC，也就是JVM中不存在该Class的任何实例
    - 加载该类的`ClassLoader`已经被GC
    - 该类对应的`java.lang.Class`对象没有在任何地方被引用，如不能在任何地方通过反射访问该类的方法

- 3.**本地方法栈**中JNI（即一般说的Native方法）中的引用

###  二、JVM常见GC算法

- **标记-清除算法**：效率低，容易产生内存碎片

- **复制算法**：将内存划分为相等两块，其中一块内存用尽时，将存活对象复制到另一块内存中未使用的区域：复制操作较多，效率低；在对象存活率高的时候，效率有所下降

- **标记-整理算法**：将所有**存活对象**向一端移动，然后清理掉端边界以外的内存：没有内存碎片

- **分代收集算法**：一般把Java堆分为**新生代**和**老年代**。

  - **新生代**：复制算法

    - 将堆内存分为一块较大的`Eden`空间和2块较小的`Survivor`空间（`From Survivor` 和`To Survivor`）。每次使用`Eden`和其中一个`Survivor` ，当回收时将`Eden`和`Survivor`中还存活的对象一次性拷贝到另一个`Survivor`，然后清理掉`Eden`和`Survivor`

      > `Hotspot` 虚拟机默认`Eden`、`From Survivor`和 `To Survivor`大小比例为8:1:1，也就是每次只有10%的内存是“浪费”的

  - **老年代**：标记-清除、标记-整理算法

### 三、常见垃圾收集器

- 1.新生代中：
  - `Serial`：**单线程**收集器，收集时会`Stop The World`，`STW`；在新生代使用**复制收集算法**，在老年代使用**标记-整理算法**。虚拟机运行在`Client`模式时的默认**新生代**收集器
  - `ParNew`：`Serial`在新生代的**多线程版本**，使用**复制算法**。虚拟机运行在`Server`模式时的默认**新生代**收集器
  - `Parallel Scavenge`：多线程收集器，**复制算法**，追求**吞吐量最大化**（即GC时间占总运行时间最小），允许较长时间的`STW`换取总吞吐量最大化

- 2.老年代中：
  - `CMS`：以**最短停顿时间**为目标的多线程收集器，**标记-清除算法**，它并不能达到GC效率最高，但能尽可能降低GC时服务的停顿时间
  - `Serial Old`：**单线程**收集器，老年代收集器，**标记-整理算法**
  - `Parallel Old`：老年代吞吐量优先收集器，多线程和**标记-整理算法**

### 四、Java内存泄漏的经典原因

内存泄漏是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成内存空间的浪费称为内存泄漏。内存泄露有时不严重且不易察觉，这样开发者就不知道存在内存泄露，但有时也会很严重，会提示你Out of memory。

#### 1.Java内存泄漏定义：

内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，

- 首先，这些对象是**可达的**，即在有向图中，存在通路可以与其相连；
- 其次，这些对象是**无用的**，即程序以后不会再使用这些对象。

如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。

#### 2.常见内存泄漏场景

Java内存泄漏的根本原因是：**长生命周期的对象持有短生命周期对象的引用**。尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景。

- **对象定义在错误的范围** ：如类成员变量在类存活时间较长时不会被回收，如果只有类中的方法调用某些变量，尽量写成局部变量
- **异常处理不当**：如数据库连接由于异常没有及时关闭，应该在finally块中保证数据库关闭
- **集合数据管理不当**：
  - 使用`Array-based`的数据结构（`ArrayList`,`HashMap`等）时，尽量减少`resize`，在创建的时候尽量确定`size`，减少`resize`可以避免没有必要的`array copying`，GC碎片等问题
  - 如果只需要顺序访问`List`，不需要随机访问，用`LinkedList`代替`ArrayList`