---
title: 神奇的位运算
layout: post
categories: 数据结构与算法
tags: LeetCode
---
[190. 颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/comments/)

## 位运算符
在解本题前，首先需要弄明白常见的位运算符，分别是：按位与（&）、按位或（|）、按位异或（^）、按位取反（~）、按位左移（<<）、按位右移（>>）

#### 按位与（&）
对两个数进行操作，然后返回一个新的数，这个数的每个位都需要两个输入数的同一位都为1时才为1，如下图：

![Image Title](http://ww1.sinaimg.cn/large/007Ns0Faly1g7vqkdb2k1j30op0bhjrz.jpg)

#### 按位或（|）
比较两个数，然后返回一个新的数，这个数的每一位设置1的条件是两个输入数的同一位都不为0(即任意一个为1，或都为1)，如下图：

![Image Title](http://ww1.sinaimg.cn/large/007Ns0Faly1g7vqkdb7muj30on0beaam.jpg)

#### 按位异或（^）
比较两个数，然后返回一个数，这个数的每个位设为1的条件是两个输入数的同一位不同，如果相同就设为0，如下图：

![Image Title](http://ww1.sinaimg.cn/large/007Ns0Faly1g7vqkdb2yyj30on0bfq3i.jpg)

#### 按位取反（~）
对一个操作数的每一位都取反，如下图：

![Image Title](http://ww1.sinaimg.cn/large/007Ns0Faly1g7vqkdb0y4j30og06wdg7.jpg)

#### 按位左移（<<）
将操作数的所有位向左移动指定的位数。

下图展示了11111111 << 1（11111111 左移一位）的结果。蓝色数字表示被移动位，灰色表示被丢弃位，空位用橙色的0填充。

![Image Title](http://ww1.sinaimg.cn/large/007Ns0Faly1g7vqs5j53zj30rn0bpn0i.jpg)

#### 按位右移（>>）
将操作数的所有位向又移动指定的位数。

下图展示了11111111 >> 1（11111111 右移一位）的结果。蓝色数字表示被移动位，灰色表示被丢弃位，空位用橙色的0填充。

![Image Title](http://ww1.sinaimg.cn/large/007Ns0Faly1g7vqs5j8t6j30rp0bxgoz.jpg)

在Java中，还存在 无符号右移 `>>>`, 此时 有符号右移 `>>` 和 无符号右移 `>>>` 有重大区别


#### Java中`>>`和`>>>`的区别

> 计算机中所存储和操作的是数字的__补码__。因此在遇到__负数__的位移运算时需要注意

##### 有符号右移运算符 `>>`
将一个数的各二进制位全部右移若干位,移到低位(右端)的被舍弃,高位(左端)则补一个等于符号位的数字，即为正数补0，负数补1。可以记为：__符号位不变，左边补上符号位__

这里，用8位的数字来说明一下为什么`-5 >> 1 = -3`。
首先，我们看一下-5的形式：
> 源码：1000 0101  
> 
> 反码：1111 1010 (非符号位按位取反)  
> 
> 补码：1111 1011 (反码转补码：反码加1)

右移一位之后：
> 补码：1111 1101 (因为是负数，高位补1)  
> 
> 反码：1111 1100 (补码转反码：补码减1)  
> 
> 原码：1000 0011 (补码转原码：非符号位按位取反再加1) 

##### 无符号右移运算符 `>>>`
将一个数的各二进制位无符号右移若干位，与运算符>>相同，移出的低位被舍弃，但不同的是最高位__补0__

同样，用8位的数字来说明一下为什么`-5 >>> 1 = 125`。
首先，我们看一下-5的形式：
> 源码：1000 0101  
> 
> 反码：1111 1010 (非符号位按位取反)  
> 
> 补码：1111 1011 (反码转补码：反码加1)

右移一位之后：
> 补码：0111 1101 (无符号右移，高位补0，此时已是正数)  
> 
> 反码：0111 1101  
> 
> 原码：0111 1101 (正数的原码、反码和补码都相同)  


## 本题题解

    // 每次取传入参数的最后一位( n & 1)，然后与要返回的结果相 “ 或 ”，
    // 把传入参数 n 右移 1 位，要返回的结果左移一位
    public int reverseBits(int n) {
        int result = 0;
        // Integer.SIZE 返回以二进制补码表示的整数的二进制位数，此处也可写32
        for (int i = 0; i < Integer.SIZE; i ++) { 
            // << 表示有符号左移
            result <<= 1;
            result |= n & 1; // n & 1 得到n的最后一位
            // >>> 表示无符号右移
            n >>>= 1;
        }
        return result;
    }

在Java Integer类的源码中，Integer.reverse的解法看起来非常秀，有必要研究一下


    // java Integer.reverse源码的方法
    public int reverseBits(int i) {
        // HD, Figure 7-1
        i = (i & 0x55555555) << 1 | (i >>> 1) & 0x55555555;
        i = (i & 0x33333333) << 2 | (i >>> 2) & 0x33333333;
        i = (i & 0x0f0f0f0f) << 4 | (i >>> 4) & 0x0f0f0f0f;
        i = (i << 24) | ((i & 0xff00) << 8) | ((i >>> 8) & 0xff00) | (i >>> 24);
        return i;
    }
    
乍看之下一脸懵逼，不过弄清细节的话还是好理解的:  
首先0x55555555、0x33333333、0x0f0f0f0f、0xff00 表示十六进制数(0x为十六进制的前缀标识，0为八进制的前缀标识，十进制没有前缀标识)  

> 为何在涉及位操作程序中会出现这些整数呢？

因为这些整数的二进制形式很特殊，可以借助Windows系统自带的计算器，快捷计算出该整数的二进制形式

0x55555555 = 0101_0101_0101_0101_0101_0101_0101_0101 (偶数位为0，奇数位为1）  

0x33333333 = 0011_0011_0011_0011_0011_0011_0011_0011 (1和0每隔两位交替出现)  

0x0f0f0f0f = 0000_1111_0000_1111_0000_1111_0000_1111 (1和0每隔四位交替出现)  

0xff00 = ‭‭0000_0000‬_1111_1111_0000_0000‬（中间8位为1，其余位为0）  


现在再来看代码：

    i = (i & 0x55555555) << 1 | (i >>> 1) & 0x55555555;
    
以题目给的示例1说明：  
此时 i = 43261596, 二进制 0000_0010_1001_0100_0001_1110_1001_1100  
##### 左侧
`i & 0x55555555` 的结果如下  

> 0000_0010_1001_0100_0001_1110_1001_1100  
> 
> 0101_0101_0101_0101_0101_0101_0101_0101  
> 
> 0000_0000_0001_0100_0001_0100_0001_0100  

再左移1位：  
> 0000_0000_0010_1000_0010_1000_0010_1000  

##### 右侧
`i >>> 1` 的结果如下
> 0000_0001_0100_1010_0000_1111_0100_1110  

再和0x55555555按位与：
> 0000_0001_0100_1010_0000_1111_0100_1110  
> 
> 0101_0101_0101_0101_0101_0101_0101_0101  
> 
> 0000_0001_0100_0000_0000_0101_0100_0100  

##### 左侧与右侧按位或：  
> 0000_0000_0010_1000_0010_1000_0010_1000  
> 
> 0000_0001_0100_0000_0000_0101_0100_0100  
> 
> 0000_0001_0110_1000_0010_1101_0110_1100  


此时对比i初始值：  
> 0000_0010_1001_0100_0001_1110_1001_1100(初始)  
> 
> 0000_0001_0110_1000_0010_1101_0110_1100(当前)  

__有没有发现，在执行完第一步操作后，相邻位进行了互换__？

后面的过程类似：

    i = (i & 0x33333333) << 2 | (i >>> 2) & 0x33333333;
    
执行后结果：  
> 0000_0100_1001_0010_1000_0111_1001_0011  

__在执行完第二步操作后，相邻两位为一组进行了互换__

    i = (i & 0x0f0f0f0f) << 4 | (i >>> 4) & 0x0f0f0f0f;
    
执行后结果：  
> 0100_0000_0010_1001_0111_1000_0011_1001

__在执行完第三步操作后，相邻四位为一组进行了互换__

    i = (i << 24) | ((i & 0xff00) << 8) | ((i >>> 8) & 0xff00) | (i >>> 24);
    
执行后结果：  
> 0011_1001_0111_1000_0010_1001_0100_0000  

__在执行完最后一次操作后，先是以字节（八位）为一组进行了互换，再以十六位为一组进行互换__

#### 还是不知所以然？

代码第一行有一个注释， "HD, Figure 7-1"，这是什么意思呢？HD表示的是一本书，书名为Hacker's Delight，HD是它的缩写，Figure 7-1是书中的图7-1，这本书中，相关内容如下图所示：
![Image Title](http://ww1.sinaimg.cn/large/007Ns0Faly1g7whfjexzpj32es1rcx4x.jpg)


可以看出，Integer中reverse的代码就是拷贝了这本书中图7-1的代码，这个代码的解释在图中也说明了，我们翻译一下。

高效实现位翻转的基本思路，首先交换相邻的单一位，然后以两位为一组，再交换相邻的位，接着是四位一组交换、然后是八位、十六位，十六位之后就完成了。这个思路不仅适用于二进制，十进制也是适用的，为便于理解，我们看个十进制的例子，比如对数字12345678进行翻转，

第一轮，相邻单一数字进行互换，结果为：

21 43 65 87

第二轮，以两个数字为一组交换相邻的，结果为：

43 21 87 65

第三轮，以四个数字为一组交换相邻的，结果为：

8765 4321

翻转完成。

对十进制而言，这个效率并不高，但对于二进制，却是高效的，因为__二进制可以在一条指令中交换多个相邻位__。

这行代码就是对相邻单一位进行互换：

`x = (x & 0x55555555) <<  1 | (x & 0xAAAAAAAA) >>>  1;`

5的二进制是0101，0x55555555的二进制表示是：

`01010101010101010101010101010101`  

`x & 0x55555555`就是取x的奇数位。

A的二进制是1010，0xAAAAAAAA的二进制表示是：

`10101010101010101010101010101010`  

`x & 0xAAAAAAAA`就是取x的偶数位。

`(x & 0x55555555) <<  1 | (x & 0xAAAAAAAA) >>>  1;`  

表示的就是x的奇数位向左移，偶数位向右移，然后通过|合并，达到相邻位互换的目的。__这段代码可以有个小的优化，只使用一个常量0x55555555，后半部分先移位再进行与操作__，变为：

`(i & 0x55555555) << 1 | (i >>> 1) & 0x55555555;`  

同理，如下代码就是以两位为一组，对相邻位进行互换：

`i = (i & 0x33333333) << 2 | (i & 0xCCCCCCCC)>>>2;`  

3的二进制是0011，0x33333333的二进制表示是：

`00110011001100110011001100110011` 

`x & 0x33333333`就是取x以两位为一组的低半部分。

C的二进制是1100，0xCCCCCCCC的二进制表示是：

`11001100110011001100110011001100`  

`x & 0xCCCCCCCC`就是取x以两位为一组的高半部分。

`(i & 0x33333333) << 2 | (i & 0xCCCCCCCC)>>>2;`  

表示的就是x以两位为一组，低半部分向高位移，高半部分向低位移，然后通过|合并，达到交换的目的。同样，__可以去掉常量0xCCCCCCCC__，代码可以优化为：

`(i & 0x33333333) << 2 | (i >>> 2) & 0x33333333;`  

同理，下面代码就是以四位为一组，进行交换。

`i = (i & 0x0f0f0f0f) << 4 | (i >>> 4) & 0x0f0f0f0f;`  

到以八位为单位交换时，就是字节翻转了，可以写为如下更直接的形式。

`i = (i << 24) | ((i & 0xff00) << 8) | ((i >>> 8) & 0xff00) | (i >>> 24); ` 

`i << 24` 最低八位挪到最高八位  

`(i & 0xff00) << 8` 右边 第二个八位 挪到 左边 第八位，`i & 0xff00` 保留右边第二个八位，再向左移动八位  
 
`(i >>> 8) & 0xff00` 左边 第二个八位 挪到 右边 第二个八位，`i >>> 8` 向右移动八位,再进行 `& 0xff00` 保留的是右边第二个八位  
 
`i >>> 24` 最高八位挪到最低八位
这四个结果再进行或操作|，就达到了翻转的目的。
---
reverse代码为什么要写的这么晦涩呢？或者说不能用更容易理解的方式写吗？比如说，实现翻转，一种常见的思路是，第一个和最后一个交换，第二个和倒数第二个交换，直到中间两个交换完成。如果数据不是二进制位，这个思路是好的，但对于二进制位，这个效率比较低。

CPU指令并不能高效的操作单个位，它操作的最小数据单位一般是32位（32位机器），另外，CPU可以高效的实现移位和逻辑运算，但加减乘除则比较慢。

reverse是在充分利用CPU的这些特性，并行高效的进行相邻位的交换，也可以通过其他更容易理解的方式实现相同功能，但很难比这个代码更高效。